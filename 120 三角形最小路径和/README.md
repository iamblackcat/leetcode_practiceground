## 思路

将三角形映射到矩形网格中，同样的处理方法，三角形特殊的一点在于这儿只能往下一行，下一行的同列或列+1位置，意味着三角形右侧的边需要特殊处理（没有从同一列直接向下一行的路径）。

第一步初始化dp数组，dp的值代表到达该位置的最小路径。

第二步处理边缘状态（左侧边，即dp\[i\]\[0\]），只能一条路径下来，同样值就从上加下来即可。

第三步动态规划，从（1，1）位置开始遍历，但右侧边缘的位置，即dp\[i\]\[len(dp\[i\])-1\]的值需要单独处理。转移方程：
$$
dp[i][j] = min(dp[i-1][j]+triangle[i][j], dp[i-1][j-1]+triangle[i][j])
$$

## 进阶——只使用O(n)空间

> 你可以只使用 `O(n)` 的额外空间（`n` 为三角形的总行数）来解决这个问题吗？

进阶只要求使用O(n)，但特殊的是，该三角形每行的元素数，等于行数。每行的dp值只取决于上一行，又最大长度行即为n，所以不难解。

要注意的是，每行内的遍历从要右向左，因为每行的值是取决于上一行同列以及上一行同列左侧一个的值，从左向右更新一维dp数组的话，左侧值被更新了，后续就没法用了。

~~错误了几次，在debug中走过来的，主要犯错在更新两个边的dp[j]~~

